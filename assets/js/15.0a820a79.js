(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{377:function(t,a,r){"use strict";r.r(a);var e=r(19),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[t._v("#")]),t._v(" JS")]),t._v(" "),r("h3",{attrs:{id:"深浅拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深浅拷贝"}},[t._v("#")]),t._v(" 深浅拷贝")]),t._v(" "),r("ul",[r("li",[t._v("浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。浅拷贝的一些方法：Object.assign()，展开运算符...，Array.prototype.concat()。")]),t._v(" "),r("li",[t._v("深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。深拷贝的实现： JSON.parse(JSON.stringify())，递归方法。")])]),t._v(" "),r("h3",{attrs:{id:"new-发生了什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new-发生了什么"}},[t._v("#")]),t._v(" new 发生了什么")]),t._v(" "),r("ul",[r("li",[t._v("创造一个全新的对象")]),t._v(" "),r("li",[t._v("这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象")]),t._v(" "),r("li",[t._v("这个新对象会绑定到函数调用的 this")]),t._v(" "),r("li",[t._v("如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象")])]),t._v(" "),r("h3",{attrs:{id:"new-一个构造函数-如果函数返回-return-、-return-null-return-1-return-true-会发生什么情况"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new-一个构造函数-如果函数返回-return-、-return-null-return-1-return-true-会发生什么情况"}},[t._v("#")]),t._v(" new 一个构造函数，如果函数返回 return {} 、 return null ， return 1 ， return true 会发生什么情况？")]),t._v(" "),r("p",[t._v("如果函数返回一个对象，那么new 这个函数调用返回这个函数的返回对象，否则返回 new 创建的新对象")]),t._v(" "),r("h3",{attrs:{id:"事件流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[t._v("#")]),t._v(" 事件流")]),t._v(" "),r("p",[t._v('事件流是网页元素接收事件的顺序，"DOM2级事件"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。\n首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。\n虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。')]),t._v(" "),r("h3",{attrs:{id:"浏览器缓存策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略"}},[t._v("#")]),t._v(" 浏览器缓存策略")]),t._v(" "),r("p",[t._v("浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：\n强制缓存和协商缓存，强缓优先于协商缓存。")]),t._v(" "),r("ul",[r("li",[t._v("强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。")]),t._v(" "),r("li",[t._v("协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified\n通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。")])]),t._v(" "),r("h4",{attrs:{id:"http缓存都是从第二次请求开始的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http缓存都是从第二次请求开始的"}},[t._v("#")]),t._v(" HTTP缓存都是从第二次请求开始的：")]),t._v(" "),r("blockquote",[r("p",[t._v("第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；\n第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。")])]),t._v(" "),r("h4",{attrs:{id:"强缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),r("h5",{attrs:{id:"cache-control"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-control")]),t._v(" "),r("ul",[r("li",[t._v("http1.1 的字段")]),t._v(" "),r("li",[t._v("优先级比Expires高")]),t._v(" "),r("li",[t._v("Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。")]),t._v(" "),r("li",[t._v("解决了Expires在浏览器时间被手动更改导致缓存判断错误的问题。")]),t._v(" "),r("li",[t._v("常见的值：\n"),r("ol",[r("li",[t._v("max-age：即最大有效时间。")]),t._v(" "),r("li",[t._v("must-revalidate：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。")]),t._v(" "),r("li",[t._v("no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜。")]),t._v(" "),r("li",[t._v("no-store: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。")]),t._v(" "),r("li",[t._v("public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)")]),t._v(" "),r("li",[t._v("private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。")])])])]),t._v(" "),r("h5",{attrs:{id:"expires"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),r("ul",[r("li",[t._v("该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。")]),t._v(" "),r("li",[t._v("Expires是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。")]),t._v(" "),r("li",[t._v("用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。")])]),t._v(" "),r("h4",{attrs:{id:"协商缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),r("ul",[r("li",[t._v("协商缓存的状态码由服务器决策返回200或者304")]),t._v(" "),r("li",[t._v("当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。")]),t._v(" "),r("li",[t._v("协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）")]),t._v(" "),r("li",[t._v("Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。")]),t._v(" "),r("li",[t._v("Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。")])]),t._v(" "),r("h3",{attrs:{id:"介绍防抖节流原理、区别以及应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍防抖节流原理、区别以及应用"}},[t._v("#")]),t._v(" 介绍防抖节流原理、区别以及应用")]),t._v(" "),r("h4",{attrs:{id:"防抖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#防抖"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),r("p",[t._v("原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n适用场景：")]),t._v(" "),r("ul",[r("li",[t._v("按钮提交场景：防止多次提交按钮，只执行最后提交的一次")]),t._v(" "),r("li",[t._v("搜索框联想场景：防止联想发送请求，只发送最后一次输入")])]),t._v(" "),r("h4",{attrs:{id:"节流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),r("p",[t._v("原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n适用场景")]),t._v(" "),r("ul",[r("li",[t._v("拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动")]),t._v(" "),r("li",[t._v("缩放场景：监控浏览器resize")])]),t._v(" "),r("p",[t._v("使用时间戳实现\n使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。")]),t._v(" "),r("h3",{attrs:{id:"闭包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),r("p",[t._v("函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。")]),t._v(" "),r("p",[t._v("函数执行分成两个阶段(预编译阶段和执行阶段)。")]),t._v(" "),r("ul",[r("li",[t._v("在预编译阶段，如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。")]),t._v(" "),r("li",[t._v("执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持用该“闭包”的引用，所以内部函数可以继续使用“外部函数”中的变量")])])])}),[],!1,null,null,null);a.default=v.exports}}]);